---
title: 【计算机网络】数据链路层
date: 2021-08-02 15:55:53.0
updated: 2021-09-03 10:35:32.689
url: /archives/计算机网络数据链路层
categories: 
- 基础知识
tags: 
- 基础知识
- 计算机网络

---
了解数据链路层再分层协议中的位置，重点了解以太网协议

<!--more-->

## 概览 & 目标

希望先仔细看一下这个部分，对数据链路层的方位、解决的问题有所了解后，再对具体的协议进行了解。

### 数据链路层在五层模型中的位置

数据链路层在物理层之上，网络层之下。

- **对于发送方而言：** 将数据报交给数据链路层处理，数据链路层将数据包封装成帧，交由物理层进行传输；
- **对于接收方而言：** 监听物理层的信号，将帧从连续的01信号中抽出，并将帧解开，将其中的数据报交给网络层处理。

### 数据链路层面临的场景&解决的问题

#### 数据链路层面临两种场景：

- **点对点直连的网络**：两个设备之间通过物理链路直接连接，不需要考虑其他设备的干扰；

- **共享物理链路**：多个设备共用一个物理层信道通信，会相互影响；

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/traslate_layer_models.svg" title="1. 物理链路模型 （a）点到点直接通信（b）共享物理链路" />

<center><b>1. 物理链路模型 （a）点到点直接通信（b）共享物理链路</b></center>

#### 点对点网络中需要解决的问题

点对点网络中，双方同时监听同一条信道。获取到的信道上的数据一定是由对方发出，发向自己的。因此只需要解决两个问题：

- **封装帧与解帧问题**：监听信道时，会获取连续的一串01，收到什么样的数据时表示帧开始，收到什么样的数据时表示帧结束？
- **差错检测问题**：物理链路可能会出现差错，如何鉴别收到的帧和发出的帧相同？

#### 共享物理链路时需要解决的问题

共享物理链路的场景，实质上是点对点问题的加强版。除了解决点对点时产生的问题外，还需要解决：

- **数据选择问题**：共享信道上有很多数据，我只想收到属于自己的，应该如何处理？
- **物理链路冲突问题**：大家都在用物理信道，可是物理信道中同时只能有一个人发数据，应该怎么解决？

### 数据链路层的实现方式

了解数据链路层协议的实现方式，对了解里面的一些算法会有很大帮助。他们大多不是由软件实现的，而是**由硬件实现**的。它们的区别在于：

- 软件需要占用CPU资源；
- 硬件作为外部设备存在，像是磁盘、时钟、键盘等等，只需要在事件发生时，向操作系统报告即可。

### 需要学习的协议

- **PPP协议**：学习点对点通信帧的设计；
- **以太网协议**：学习共享物理链路时帧的设计；
- **CSMA协议**：学习共享物理链路时怎么发包能够避免冲突；

## PPP(Point-to-Point-Protocol)

上面有提过，`PPP`解决的是两个设备使用物理链路直接连接时的通信问题。我们从`PPP`的帧设计开始。

### PPP 帧设计

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/PPPFrameWithProtocol.svg" title="2. PPP帧格式" />

<center><b>2. PPP帧格式</b></center>

- `PPP`帧固定以字节`01111110`开头，以字节`01111110`结尾，我们将这个标识符称为 **`Flag`**；

- `Address`, `Control`都是为了协议后期的扩展而预留的，暂时没有含义；
- `Protocol`用于记录上层的协议类型；
- `Data`用于存储上层的数据报；
- `Check`使用`CRC`校验码来确保数据正确；



帧的基本格式已经了解，但是还有很多的问题需要解决，接下来我们逐一了解。

### Data中存在Flag数据应该怎么办？

解决方案：在数据中检测出`01111110`或`01111101`字节的时候就向前填充`01111101`。

这个方案非常抽象，我们结合字符串输出时的转义符号就很好理解了。当我们想要输出一些有特殊含义的字符时，就会使用`\n`, `\r`这样的方法进行输出，这里的`\`就作为转义符存在。当我们想要输出`\`时，需要使用`\\`来输出。

这里，`011111110`就是作为特殊符号存在，`011111101`作为转义符存在。

### Check如何生成，如何检验？

`PPP`中的`Check`使用`Crc(CylicRedundancyCheck)`作为校验码，`CRC`的原理比较复杂，我懒得学了。可以去看这个视频。

[《[CRC校验]手算与直观演示》](https://www.bilibili.com/video/BV1V4411Z7VA?from=search&seid=6363581067369572742)



`PPP`协议通过设计`Flag`字节标记数据起点、终点，通过添加转义符避免数据中出现`Flag`，并通过`Check`位对发送的数据进行校验，以保证收到的数据大概率正确。它考虑的场景较为简单，通信双方不需要考虑数据发送的目标等问题，因此`PPP`协议比较简单。接下来我们将了解共享信道中数据链路层常用的以太网协议。

## 以太网

PPP协议认为两个节点之间通过一条独立的信道连接，所以在帧中无需指定启发地址、到达地址。但是以太网面临共享物理链路的使用场景，接下来将从以太网帧格式出发，来学习：

- 以太网帧如何设计？
- 以太网如何处理共享信道冲突的问题？

### 以太网帧

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/EthernetFrameFMT.svg" title="3. 以太网帧格式" />

<center><b>3. 以太网帧格式</b></center>

以太网帧由前导、主体两部分组成：

**前导部分**：图中灰色部分，长度为8字节，前七个字节全部为`10101010`，最后一个字节为`10101011`。前导部分主要用于进行同步，最后一个字节出现`11`后，接受者开始进行接收。

**主体部分：** 整体设计与`PPP`帧类似：

- `Target`, `Origin`：各6字节，记录期望接收方、发送方的`MAC`地址；
- `Type`：记录`Data`中存储的上层协议类型；
- `FCS`：校验信息；

**特殊的：** 有一些特殊的`MAC`地址，在这里进行简单的说明：

- `0xffffff`：全是1，表示广播，共享同一物理链路的机器都会收到广播的信息；
- `0x000000`：全是0，表示待填充；

### 以太网解决信道冲突

#### 什么是信道冲突

有多台计算机共享一条物理信道的所有频段，现在机器A，机器B都想发送信号。不幸的是：一条物理信道同时只能承载一条消息，A,B同时发送信号会导致冲突。这种同时发送消息导致消息发送失败的情况就叫做信道冲突。

#### 早期的解决方案

##### **ALOHA协议**：

需要发送帧的时候就直接发送，监测到冲突后，等待随机时间后再进行发送；

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/ALOHA_SHOW.svg" title="4. 纯ALOHA协议示意图" />

<center><b>4. 纯ALOHA协议示意图</b></center>

纯ALOHA协议的冲突频率过高，仅仅是一个能用的协议，作为历史了解即可。

##### 时隙ALOHA协议：

纯ALOHA协议发送的时间是随机的，这导致经常发生冲突的情况。时隙ALOHA讲时间分割为时间片，发送行为必须在时间片发送时开始，在时间片结束前结束。


<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/TIME_STEP_ALOHA_SHOW.svg" title="5. 时隙ALOHA协议示意图" />

<center><b>5. 时隙ALOHA协议示意图</b></center>


当检测到冲突后，会将发送行为随机推迟几个时间片进行。时隙ALOHA的实质是：**通过划分时隙的方法将冲突带来的代价减少**，来换取更高的信道利用率。

时隙ALOHA需要所有设备的时钟统一，同时冲突的发生依然是随机的。

#### 以太网中的解决方案——CSMA/CD

`CSMA/CD`全名是：**Carrier Sense Multiple Access with Collision Detectio**。结合我个人的理解，他的中文名是：基于**冲突检测**的**载波侦听多路访问**。在这里不会讨论冲突检测如何实现、载波侦听原理是什么这样的问题。可以抽象的理解为：链路层设备具有这样的能力。我们主要学习如何基于冲突检测完成多路访问控制。



一句话概括`CSMA/CD`的原理就是：先监听后发送，发送时保持监听。

- **先监听后发送**：发送前先监听链路状态，检测到空闲后再进行发送（防止直接产生冲突）；
- **发送时监听**：发送时监听链路状态，如果产生冲突立刻停止发送（避免发生冲突后产生的浪费）；



来一段真实的：

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/CSMACD_FLOW.svg" title="6. CSMA/CD流程示意" />

<center><b>6. CSMA/CD流程示意</b></center>

- `(a)`：A节点想要发送信息，先对链路进行监听，发现链路空闲，可以发送；
- `(b)`：A节点发送信息，此时B节点想要发送消息，对链路进行监听，发现空闲，可以发送；
- `(c)`：B发送消息，链路上同时存在A、B发出的两条消息；
- `(d)`：A、B两条消息发生碰撞；
- `(e)`：A发送的数据到B，B检测到冲突，停止发送数据，A未感知到冲突，继续发送；
- `(f)`：B发送的数据到A，A检测到冲突，停止发送数据；



通过上面的流程，我们可以了解到`CSMA/CD`运行的大致流程。接下来我们讨论两个问题：

- `CSMA/CD`最短帧长问题；
- 监测到冲突后的重传机制问题；



##### `CSMA/CD`最短帧长

回到上面A，B冲突的问题，如果A的数据过短，导致A在发送结束前就结束了监听，那么A就无法知道自己的数据冲突。那么这样，就无法完成后续的重传。所以，需要限制帧的长度，以保证冲突能够被发现。这里假设：

- `d`：物理链路的长度；
- `v`：信号在物理链路中传播的速度；
- `l`：发送数据的大小；
- `s`：发送数据的速率；

按照我们刚才的描述，他们之间的关系应当满足：$\frac{2d}{v} \le \frac{l}{s}$​​；

这个公式的含义是：在最坏的情况下（A是链路的最左端，B是最右端，A发送的数据到达B之前，B开始发送），A在完成数据传输前始终能够检测到链路上的冲突。



##### 监测到冲突后的重传

这里有一些名词：

-  0坚持：监测到冲突后，随机等待一个时间后再继续监听信道，等待信道可用后重新发送；
-  1坚持：监测到冲突后，持续监听信道，信道空闲后直接发送；
-  p坚持：以概率`p`执行1坚持，以概率`(1-p)`执行0坚持逻辑；



## 其他

简单介绍一下交换机。首先，交换机是数据链路层设备，在交换机眼中是没有IP地址这个概念的。交换机上有多个端口，每个端口连接一个物理链路，他做的事情就是：

- 根据MAC地址，将信号转发到某一个端口上；

他的作用是：将多个物理链路联通，纳入同一个网络中。

<img src="https://goleveldb-1301596189.cos.ap-guangzhou.myqcloud.com/SWAP_POSITION.svg" title="7. 交换机作用示意" />

<center><b>7. 交换机作用示意</b></center>

- `(a)`：这里展示的是没有交换机的网络，所有设备要通过一根网线连接在一起，网线挂了，所有设备也就都挂了；
- `(b)`：有交换机的网络，交换机通过鉴别帧中的目标MAC地址，将帧转发到某个链路。

交换机的引入使得所有用户可以不依赖同一根网线，增加了网络的可扩展性。



## 总结

这一章节我们学习了：

- 数据链路层解决的问题；
- 点对点网络中数据帧的设计；
- 共享网络中数据帧的设计；
- 共享网络中的访问控制设计；
- 交换机的作用和基本原理；